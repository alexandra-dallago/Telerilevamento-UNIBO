#Il seguente codice è stato scritto utilizzando questi pacchetti precedentemente scaricati.
##Dopo aver installato i seguenti pacchetti con la funzione "install.packages("")" (NB: per installare il pacchetto bisogna inserirlo tra le virgolette), è necessario richiamare la funzione tramite il codice "library()" (richiamando la funzione non è necessario scrivere il pacchetto con le virgolette perchè è già presente in R una volta installato)
library(terra)       #Pacchetto R specializzata per l'analisi geospaziale e la manipolazione di dati raster.
library(imageRy)     #Pacchetto R usato per gestire dati raster, la visualizzazione, l'importazione la modifica delle immagini. Inoltre, facilita la condivisione delle immagini.
library(ggplot2)     #Pacchetto R per la creazione di grafici statistici.
library(patchwork)   #Pacchetto R usato per organizzare e personalizzare la disposizione di più grafici. 
library(viridis)     #Pacchetto R usato per dare delle palette di colore distinguibili anche dalle persone affette da daltonismo. 

#"setwd()" è un comando usato per impostare la directory del lavoro. In questo caso è stata impostata nella cartella "immagini d'esame" nel desktop del computer.
setwd("C:/Users/alexa/Desktop/Immagini esame")

#IMPORTAZIONE DELLE IMMAGINI
##Le immagini sono state prese dal sito "Copernicus Browser" sulla zona di Sappada e Forni Avoltri (UD), Friuli Venezia Giulia per 3 anni diversi (2015-2018-2023) nei mesi di ottobre, per confrontare i danni causati dalla tempesta Vaia del 2018 e la copertura nevosa.
####Per cisacun anno sono state scaricate due immagini dal satellite "sentinel 2", rispettivamente immagini "true color" aventi le bande b4, b3 e b2 (red, green, blue); e una seconda immagine "false color" aventi le bande b8, b4 e b3 (nir, red, green). Lo scopo è quello di prelevare la banda b8, ovvero quela del nir, per importarla in un unico oggetto assieme alle altre bande b4, b3 e b2
####Importiamo le immagini dalla cartella indicata nella directory tramite la funzione "rast()" del pacchetto "terra".

TC2015<-rast("tc2015vaia.jpg")      #Importazione dell'immagine jpg nell'oggetto chiamato "TC2015" per l'anno 2015. Le bande presenti in quessto oggetto sono b4, b3 e b2.  
NIR2015<-rast("fc2015vaia.jpg")     #Importazione dell'immagine jpg nell'oggetto chiamato "NIR2015" per l'anno 2015. Le bande presenti in quessto oggetto sono b8, b4 e b3.  

TC2018<-rast("tc2018vaia.jpg")      #Importazione dell'immagine jpg nell'oggetto chiamato "TC2018" per l'anno 2018. Le bande presenti in quessto oggetto sono b4, b3 e b2.  
NIR2018<-rast("fc2018vaia.jpg")     #Importazione dell'immagine jpg nell'oggetto chiamato "NIR2018" per l'anno 2015. Le bande presenti in quessto oggetto sono b8, b4 e b3.

TC2023<-rast("tc2023vaia.jpg")      #Importazione dell'immagine jpg nell'oggetto chiamato "TC2023" per l'anno 2023. Le bande presenti in quessto oggetto sono b4, b3 e b2.
NIR2023<-rast("fc2023vaia.jpg")     #Importazione dell'immagine jpg nell'oggetto chiamato "NIR2023" per l'anno 2023. Le bande presenti in quessto oggetto sono b8, b4 e b3.

#Warning unknown extend: per la mancata georeferenziazione delle immagini 

par(mfrow=c(1,3))     #Funzione usata per creare una finestra grafica in una griglia di righe e colonne specificando il numero di righe e colonne che in questo caso sono 1 riga e 3 colonne.
plot(TC2015)          #Le immagini vengono visualizzate tramite la funzione "plot()".
plot(TC2018)
plot(TC2023)

b15r<-TC2015[[1]]      #Tramite le parentesi quadre si specifica l'oggetto da estrarre (in questo caso l'oggetto 1, ovvero la banda del rosso, di "TC2015") per assegnarlo ad un nuovo oggetto chiamato "b15r".
b15g<-TC2015[[2]]      #Tramite le parentesi quadre si specifica l'oggetto da estrarre (in questo caso l'oggetto 2, ovvero la banda del verde, di "TC2015") per assegnarlo ad un nuovo oggetto chiamato "b15v".
b15b<-TC2015[[3]]      #Tramite le parentesi quadre si specifica l'oggetto da estrarre (in questo caso l'oggetto 3, ovvero la banda del blu, di "TC2015") per assegnarlo ad un nuovo oggetto chiamato "b15b".
b15nir<-NIR2015[[1]]   #Tramite le parentesi quadre si specifica l'oggetto da estrarre (in questo caso l'oggetto 1, ovvero la banda del nir, di "NIR2015") per assegnarlo ad un nuovo oggetto chiamato "b15nir".

b18r<-TC2018[[1]]    #Viene fatto lo stesso procendimento sopra descritto per tutti gli anni.
b18g<-TC2018[[2]]
b18b<-TC2018[[3]]
b18nir<-NIR2018[[1]]

b23r<-TC2023[[1]]
b23g<-TC2023[[2]]
b23b<-TC2023[[3]]
b23nir<-NIR2023[[1]]

vaia15<-c(b15r,b15g,b15b,b15nir)      #Uniamo in un unico oggetto, ovvero "vaia15", tutte le bande estratte rpecedentemente ottenendo così un unico oggetto avente tutte le 4 bande d'interesse, ovevro rosso, verde, blu e nir; tramite l'assegnazione "c" concatenate essendo elementi di un vettore
vaia18<-c(b18r,b18g,b18b,b18nir)
vaia23<-c(b23r,b23g,b23b,b23nir)

#Attraverso la funzione "im.plotRGB()" del pacchetto "imageRy", applichiamo il nir (b8) alle componenti rosso, verde e blu dell'immagine per vedere come queste cambiano

##Nir sul red: questo comporta una visualizzazione che evidenzia le caratteristiche della vegetazione in quanto la vegetazione rifletto molto di più nel nir rispetto alle altre superifici, facilitandone l'identificazione. E' possibile anche capirne lo stato di salute in quanto più queste sono in salute, più il nir verrà riflesso e più l'immagine sarà luminosa. di cosneguenza, la vegetazione assumerà il colore rosso. 
par(mfrow=c(1,3))
im.plotRGB(vaia15, 4,2,3)      #4,2,3 specificano rispettivamente nir, green, blu dell'oggetto "vaia15"
im.plotRGB(vaia18, 4,2,3)  
im.plotRGB(vaia23, 4,2,3) 

##Nir sul blu: accade l'opposto di ciò che succede quando il nir è sul rosso; pertanto, la vegetazione apparirà molto scura. inltre, il suolo diventerà giallo fornendo un ottimo contrasto tra vegetazione e suolo. 
par(mfrow=c(1,3))
im.plotRGB(vaia15, 1,2,4)      #1,2,4 specificano rispettivamente red, green, nir
im.plotRGB(vaia18, 1,2,4) 
im.plotRGB(vaia23, 1,2,4) 

##Nir sul green: la vegetazione apparirà verde, dando un aspetto più naturale. 
par(mfrow=c(1,3))
im.plotRGB(vaia15, 1,4,3)      #1,4,3 specificano rispettivamente red, nir, blu
im.plotRGB(vaia18, 1,4,3) 
im.plotRGB(vaia23, 1,4,3) 

#CORRELAZIONE TRA LE IMMAGINI
##Tramite la funzione "pairs()" viene creata una matrice di grafici a dispersione mostrando le relazioni bivariate tra ogni coppia di banda presente nell'oggetto. Ogni cella della matrice contiene un grafico a dispersione visualizzando la correlazione tra le bande. 
pairs(vaia15)
pairs(vaia18)
pairs(vaia23)

#CLASSIFICAZIONE DELLE IMMAGINI E CALCOLO DELLA FREQUENZA
##Viene fatta la classificazione delle immagini attraverso la funzione "im.classify()" e successivo calcolo della relativa frequenza, proporzione e percentuale del numero dei pixel.

vaia15c<-im.classify(vaia15,3)     #Classifica le immagini tramite k-means (un agoritmo di clustering che divide un insieme di dati in un numero predeterminato di gruppi basati sulla loro somiglianza) specificando il numero di cluster che in questo caso sono 3.
vaia18c<-im.classify(vaia18,3) 
vaia23c<-im.classify(vaia23,3) 

f2015<-freq(vaia15c)              #Per calcolare il numero di pixel presenti tra le diverse classificazioni da noi scelte, calcolo la frequenza e la percentuale delle classi.
f2018<-freq(vaia18c)
f2023<-freq(vaia23c)

tot2015<-ncell(vaia15c)           #Calcolo il numero totale di celle nell'immagine. 
tot2018<-ncell(vaia18c)
tot2023<-ncell(vaia23c)

prop2015=f2015/tot2015               #Calcolo la proporzione rispetto al totale.
prop2018=f2018/tot2018
prop2023=f2023/tot2023

perc2015= prop2015*100                #Calcolo della percentuale dei cluster rispetto al totale delle celle.
perc2018= prop2018*100  
perc2023= prop2023*100                

#GGPLOT E DATAFRAME 
##Creiamo un dataframe contenente le classi, numero di pixel corrispondenti a ciascuna classe per le due immagini. I dati vengono poi usati per creare due grafici a barre per confrontare le distribuzione delle classi nelle immagini.  

class<-c("snow", "forest", "soil")       #Vettore a cui vengono attribuite 3 classi.
y2015<-c(19.98092,54.42268,25.59640)                          #Vettore a cui vengono attribuite le relative percentuali calcolate precedentemente.
y2018<-c(31.83124,34.10886, 34.05817)
y2023<-c(18.23045,50.31034,31.45921)

tabout<-data.frame(class,2015,y2018,y2023)       #Dataframe dove vengono inserite le classi di terreno e le relative percentuali per entrambe le immagini.
anno2015<-ggplot(tabout,aes(x=class,y=y2015, color=class))+geom_bar(stat="identity", fill="white")+ylim(c(0,55))       #Creazione di un grafico a barre utilizzando ggplot (dal paccketto ggplot2) per rappresentare la distribuzione delle percentuali nelle 3 classi (water, forest,cities). "geom_bar()" specifica che il tipo di grafico, ovvero quello a barre."color=class" indica che le barre sono colorate in base al vettore "classe". "stat="identity"" indica che i valori forniti nei dati verranno usati per determinare l'altezza delle barre, ma "ylim(c(0,45))" indica che la scala sull'asse y è impostata da 0 a 45. "fill="white"" specifica che il colore di riempimento delle barre sarà bianco. 
anno2018<-ggplot(tabout,aes(x=class,y=y2018, color=class))+geom_bar(stat="identity", fill="white")+ylim(c(0,55)) 
anno2023<-ggplot(tabout,aes(x=class,y=y2023, color=class))+geom_bar(stat="identity", fill="white")+ylim(c(0,55))       #Creazione di un grafico a barre utilizzando ggplot (dal paccketto ggplot2) per rappresentare la distribuzione delle percentuali nelle 3 classi (water, forest,cities). "geom_bar()" specifica che il tipo di grafico, ovvero quello a barre."color=class" indica che le barre sono colorate in base al vettore "classe". "stat="identity"" indica che i valori forniti nei dati verranno usati per determinare l'altezza delle barre, ma "ylim(c(0,45))" indica che la scala sull'asse y è impostata da 0 a 45. "fill="white"" specifica che il colore di riempimento delle barre sarà bianco. 

anno2015+anno2018+anno2023                           #Unisce i due grafici a barre creati precedentemente in una sola finestra.

#TIMES SERIES 
##Visualizziamo la differenza pixel per pixel tra le due immagini usando una palette di colori per evidenziare le variazioni tra le due immagini. Osserviamo le differenze effettive tra le immagini in termini di intensità dei pixel.

#################################differenza tra le immagini della banda del NIR  
differenza<-vaia15[[4]] - vaia18[[4]] - vaia23[[4]] #Calcola la differenza pixel per pixel tra le due immagini considerando solo il quarto elemento selezionato tramite "[[4]]" che in questo caso rappresenta il nir

cl<- colorRampPalette(c("blue","white", "red")) (100)      #Crea una rampa di colori che va dal blu al bianco al rosso con 100 gradazioni.
plot(differenza, col=cl)                  #Visualizzazione dell'oggetto "differenza" con la rampa di colori "cl precedentemente creati". Osserviamo quindi la differenza tra Dublino del 1984 e Dublino 2022. Il rosso indica un forte cambiamento?????????????????????

##Uniamo le immagini risultate dalla classificazione e calcoliamo la differenza tra i risulltati; è quindi un confronto delle classificazioni delle immagini e come le classi scelte (water, forest, cities) sono cambiate.

changes<-c(vaia15c,vaia18c,vaia23c)                         #Visualizza in un array le due immagini precedentemente classificate. 
cl<- colorRampPalette(c("blue","white", "red")) (100)       #Crea una rampa di colori che va dal blu al bianco al rosso con 100 gradazioni.
plot(changes, col=cl)                                       #Visualizzo l'elemento "changes" con la rampa di colori precedentemente creata, ovvero "cl".
differences=changes[[1]]-changes[[3]]                       #Calcola la differenza pixel per pixel tra i risultati della classificazione delle immagini PERCHEEEEEE [[1]] E [[2]]???????????????????????????????
clgreen <- colorRampPalette(c("red","white","blue")) (100)  #Crea una rampa di colori che va dal rosso al bianco al blu con 100 gradazioni.
plot(differences, col=clgreen)                              #Plotta l'oggetto "differences" utilizzando la rampa di colori definita in precedenza.

##CALCOLO INDICE DI VARIABILITA': DVI E NDVI 
#Calcolo DVI: Indice di differenza di vegetazione. 
##Questo indice sfrutta l'alta capacità di riflettanza dell'infrarosso e la scarsa riflettanza del rosso per determinare, tramite una differenza, la biomassa presente in quel pixel. Scegliamo di usare il rosso e non il blu in quanto vogliamo sfruttare la firma spettrale: una sorta di imporonta digitale della luca nelle varie lunghezza d'onda; la vegetazione avrà sempre la stessa firma/andamento. Inoltre sfruttiamo i lrosso in quanto si trova vicino alla banda dell'infrarosso e possiamo anche determianre lo stato di salute della painta in base all'accresccimento del rosso o infrarosso (se aumenta da rosso a nir la pianta è sana).  
###Il valore DVI varia da +255 a -255 perchè la risoluzione radiometrica è di 8bit, quindi 255 possibilità. 

dvi2015=vaia15[[4]] - vaia15[[1]]     #Differenza tra le bande del vicino infrarosso nir [[4]] e del rosso red [[1]]. 
dvi2018=vaia18[[4]] - vaia18[[1]]    
dvi2023=vaia23[[4]] - vaia23[[1]] 
cl<-colorRampPalette(c("darkblue", "yellow", "red", "black"))(100)     #Crea una rampa di colori che va dal blu scuro, al giallo, al rosso e al nero con 100 gradazioni.

par(mfrow=c(1,3))        #Funzione usata per creare una finestra grafica in una griglia di righe e colonne specificando il numero di righe e colonne che in questo caso sono 1 riga e 2 colonne.
plot(dvi2015,col=cl)    #Le immagini vengono visualizzate tramite la funzione "plot()" e rappresentano l'indice di differenza di vegetazione per l'immagine di Dublino nel 1984 e Dublino nel 2022.
plot(dvi2018,col=cl)  
plot(dvi2023,col=cl)  

#Calcolo NDVI: indice di differenza normalizzata delle vegetazioni utilizzando i valori delle bande rosse e infrarosse delle immagini. viene calcolata con la formula NDVI=(nir-red/nir+red)
## Il valore NDVI va da +1 a -1  perchè se il nir è massimo e red minimo, insrendo nella formula otteniamo: 255-0/255+0=1 (valore massimo). Otteniamo -1 quando il nir è minimo. 

ndvi2015<-dvi2015/(vaia15[[4]]+vaia15[[1]])    #dvi2022 è il numeratore nir-red. d2022[[1]]+d2022[[2]] rappresenta il denominatore, ovvero nir+red; dove le bande sono nir=1 e red=2.
ndvi2018<-dvi2018/(vaia18[[4]]+vaia18[[1]])
ndvi2023<-dvi2023/(vaia23[[4]]+vaia23[[1]])    #dvi1984 è il numeratore nir-red. d1984[[1]]+d1984[[2]] rappresenta il denominatore, ovvero nir+red; dove le bande sono nir=1 e red=2.

par(mfrow=c(1,3))           #Funzione usata per creare una finestra grafica in una griglia di righe e colonne specificando il numero di righe e colonne che in questo caso sono 1 riga e 2 colonne.
plot(ndvi2015, col=cl)      #Le immagini vengono visualizzate tramite la funzione "plot()" e rappresentano l'indice NDVI per l'immagine di Dublino nel 1984 e Dublino nel 2022, con la relativa palette di colori.  
plot(ndvi2018, col=cl)
plot(ndvi2023, col=cl)

#ANALISI MULTIVARIATA 
##Vengono eseguite analisi multivariate come l'applicazione di una trasformata principale delle componenti (PCA) alle immagini, il calcolo della deviazione standard tramite la funzione focal(), e il calcolo della varianza delle componenti principali ottenute dalla PCA.
###Non sclego la banda:  viene eseguita la PCA sull'intera immagine senza specificare una banda. E' una analisi delle copmonenti principali dell'immagine che ci permette di portare un sistema a più bande in una sola. 

pcimage15<-im.pca(vaia15)    #La funzione im.pca() ci da i 3 valori delle componenti principali, ovvero:  136.453262  32.793144   7.449183   2.016412
pcimage18<-im.pca(vaia18)    #I valori delle 3 componenti principali sono: 87.91545, 24.08029, 13.03455
pcimage23<-im.pca(vaia23) 

tot15<-sum(136.453262, 32.793144, 7.449183, 2.016412)      #Calcolo della varianza spiegata dalle 3 componenti principali per entrambi gli anni.
var15x<-136.453262*100/tot15
var15y<-32.793144*100/tot15
var15z<-7.449183*100/tot15
var15k<-2.016412*100/tot15

var15x      #Variabilità spiegata dal primo asse
var15y      #Variabilità spiegata dal secondo asse
var15z      #Variabilità spiegata dal terzo asse
var15k

tot18<-sum(110.148775, 22.794595, 4.353711, 1.424322)
var18x<-110.148775*100/tot18
var18y<-22.794595*100/tot18
var18z<-4.353711*100/tot18
var18k<-1.424322*100/tot18

var18x
var18y
var18z
var18k

tot23<-sum(132.819884, 37.324598, 10.333292, 2.552092)
var23x<-132.819884*100/tot18
var23y<-37.324598*100/tot18
var23z<-10.333292*100/tot18
var23k<-2.552092*100/tot18

var23x
var23y
var23z
var23k

clll<-colorRampPalette(c("red","orange","yellow"))(255) 
plot(pcimage15, col=clll)
plot(pcimage18, col=clll)
plot(pcimage23, col=clll)
